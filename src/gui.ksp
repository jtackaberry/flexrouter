// Called during script initialization
macro gui_initialize
    // DECLARATIONS
    declare ui_label label_global_config (1,1)
    declare ui_menu menu_global_cc_hanging

    // Rules menu and rules buttons
    declare ui_menu menu_rules
    declare ui_button button_add
    declare ui_button button_remove
    declare ui_switch button_rule_bypass
    declare ui_switch button_rule_clone
    // TODO
    // declare ui_button button_sort


    // Rule name
    declare ui_label label_rule_name (1,1)
    declare ui_text_edit @text_rule_name

    // Keyswitch channel
    declare ui_label label_rule_keyswitch_channel (1,1)
    declare ui_menu menu_rule_keyswitch_channel

    // Source Channel (rule default)
    declare ui_label label_rule_source_channel (1,1)
    declare ui_menu menu_rule_source_channel

    // Target Channel (rule default)
    declare ui_label label_rule_target_channel (1,1)
    declare ui_menu menu_rule_target_channel

    // CC chasing behaviour
    declare ui_label label_rule_cc_chasing  (1,1)
    declare ui_menu menu_rule_cc_chasing
    declare ui_label label_rule_cc_chasing_info (1,1)


    // Keyswitches menu and keyswitch buttons
    declare ui_label label_keyswitches (1,1)
    declare ui_menu menu_keyswitches
    declare ui_button button_keyswitch_new
    declare ui_button button_keyswitch_remove
    declare ui_switch button_keyswitch_midi_find
    declare ui_button button_keyswitch_clear


    declare ui_label label_rule_keyswitch (1,1)
    declare ui_menu menu_rule_keyswitch_type
    // Key note (when keyswitch type is set to key)
    declare ui_value_edit value_rule_keyswitch_key (0, 127, VALUE_EDIT_MODE_NOTE_NAMES)
    // CC controls (when keyswitch type is set to CC)
    declare ui_value_edit value_rule_keyswitch_cc (2, 127, 1)
    declare ui_label label_rule_keyswitch_cc_slash (1,1)
    declare ui_value_edit value_rule_keyswitch_cc_value (0, 127, 1)
    // Program controls (when redirect type is set to Progran Change)
    declare ui_value_edit value_rule_keyswitch_program (0, 127, 1)
    declare ui_switch button_keyswitch_midi_learn
    declare ui_switch button_keyswitch_midi_learn_inc


    // Keyswitch source channel
    declare ui_label label_rule_keyswitch_source_channel (1,1)
    declare ui_menu menu_rule_keyswitch_source_channel

    // Keyswitch target channel
    declare ui_label label_rule_keyswitch_target_channel (1,1)
    declare ui_menu menu_rule_keyswitch_target_channel

    // Keyswitch flags
    declare ui_label label_rule_keyswitch_flags (1,1)
    declare ui_switch switch_rule_keyswitch_flags_hold_notes

    // Keyswitch action menu (block, passthrough, redirect)
    declare ui_label label_rule_keyswitch_action (1,1)
    declare ui_menu menu_rule_keyswitch_action



    // Redirect controls (when action is set to redirect)
    declare ui_label label_rule_keyswitch_redirect_to (1,1)
    declare ui_button button_rule_keyswitch_addremove[MAX_GUI_REDIRECTS_PER_KEYSWITCH]

    // Redirect type menu (key or CC)
    declare ui_menu menu_rule_keyswitch_redirect_type[MAX_GUI_REDIRECTS_PER_KEYSWITCH]

    // Key redirect controls (when redirect type is set to key)
    declare ui_value_edit value_rule_keyswitch_redirect_key[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, VALUE_EDIT_MODE_NOTE_NAMES)
    declare ui_label label_rule_keyswitch_redirect_key_velocity[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (1,1)
    declare ui_value_edit value_rule_keyswitch_redirect_key_velocity[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, 1)

    // CC redirect controls (when redirect type is set to CC)
    declare ui_value_edit value_rule_keyswitch_redirect_cc[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (2, 127, 1)
    declare ui_label label_rule_keyswitch_redirect_cc_slash[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (1,1)
    declare ui_value_edit value_rule_keyswitch_redirect_cc_value[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, 1)

    // Program redirect controls (when redirect type is set to Progran Change)
    declare ui_value_edit value_rule_keyswitch_redirect_program[MAX_GUI_REDIRECTS_PER_KEYSWITCH] (0, 127, 1)


    // Keyswitch MIDI Learn button
    declare ui_switch button_rule_keyswitch_redirect_midi_learn[MAX_GUI_REDIRECTS_PER_KEYSWITCH]
    // If not -1, then indicates the index of the keyswitch redirect that's learning.
    declare keyswitch_redirect_midi_learn_index := -1

    declare y := 10

    // CONTROL INITIALIZATION


    make_persistent(menu_rules)
    set_ui_height_px(290 + 20 * MAX_GUI_REDIRECTS_PER_KEYSWITCH)

    init_label(label_global_config, "Global Config ", 70, y, 75)
    menu_global_cc_hanging -> help := "Ensures that, for the specified CCs, zero-values are sent to all channels that had previously received events for these CCs."
    move_and_set_width(menu_global_cc_hanging, 150, y, 150)
    add_menu_item(menu_global_cc_hanging, "Allow CC Hanging", 0)
    add_menu_item(menu_global_cc_hanging, "Prevent hanging for all CCs", 1)
    add_menu_item(menu_global_cc_hanging, "Prevent hanging for CC2/64", 2)
    y := y + 30

    menu_rules -> help := "The list of user defined rules. Up to 16 are allowed."
    move_and_set_width(menu_rules, 70, y, 210)
    for i := 0 to MAX_GUI_RULES - 1
        add_menu_item(menu_rules, rules[i].name, i)
        set_menu_item_visibility(get_ui_id(menu_rules), i, rules[i].config[RULE_DEFINED])
    end for

    button_add -> help := "Add a new rule, with all fields initialized to default values."
    set_text(button_add, "Add Rule")
    move_and_set_width(button_add, 290, y, 50)

    button_remove -> help := "Remove the current rule. If there's only one rule, then it's reinitialized to default values."
    set_text(button_remove, "Remove Rule")
    move_and_set_width(button_remove, 350, y, 70)

    button_rule_bypass -> help := "Disable all keyswitches associated with this rule."
    set_text(button_rule_bypass, "Bypass Rule")
    move_and_set_width(button_rule_bypass, 430, y, 65)
    center(button_rule_bypass)

    help(button_rule_clone, "Creates a new rule, copying all settings and keyswitches from this rule.")
    set_text(button_rule_clone, "Clone Rule")
    move_and_set_width(button_rule_clone, 505, y, 65)
    center(button_rule_clone)

    // set_text(button_sort, "Sort Rules")
    // move_and_set_width(button_sort, 430, y, 60)

    y := y + 30
    init_label(label_rule_name, "Rule Name", 95, y, 95)
    text_rule_name -> help := "An aribitrary name for this rule. Be descriptive!"
    move_and_set_width(text_rule_name, 200, y, 190)

    y := y + 20
    menu_rule_keyswitch_channel -> help := "The channel on which all keyswitch events will be received. Omni means keyswitches will work on any channel."
    init_label(label_rule_keyswitch_channel, "Keyswitch Channel", 95, y, 95)
    add_menu_item(menu_rule_keyswitch_channel, "Omni", -1)
    move_and_set_width(menu_rule_keyswitch_channel, 200, y, 60)
    init_channel_menu(menu_rule_keyswitch_channel, 16)

    y := y + 20
    menu_rule_source_channel -> help := "Once a keyswitch is triggered and routes established, this is the default channel for the rule on which all MIDI events will be routed to the target channel(s). Individual keyswitches can override this."
    init_label(label_rule_source_channel, "Default Source", 95, y, 95)
    move_and_set_width(menu_rule_source_channel, 200, y, 60)
    add_menu_item(menu_rule_source_channel, "Omni", -1)
    init_channel_menu(menu_rule_source_channel, 16)

    y := y + 20
    menu_rule_target_channel -> help := "Once a keyswitch is triggered, this is the default channel for the rule to which all subsequent non-keyswitch events will be routed. Individual keyswitches can override this."
    init_label(label_rule_target_channel, "Default Target", 95, y, 95)
    move_and_set_width(menu_rule_target_channel, 200, y, 60)
    add_menu_item(menu_rule_target_channel, "Null", -1)
    init_channel_menu(menu_rule_target_channel, 64)

    y := y + 20
    menu_rule_cc_chasing -> help := "When activing keyswitches, replays the state of the given CCs to the new target channel(s). This can ensure a smooth transition between patches."
    init_label(label_rule_cc_chasing, "CC Chasing", 95, y, 95)
    move_and_set_width(menu_rule_cc_chasing, 200, y, 125)
    add_menu_item(menu_rule_cc_chasing, "No chasing", 0)
    add_menu_item(menu_rule_cc_chasing, "Chase all CCs", 1)
    add_menu_item(menu_rule_cc_chasing, "Chase common CCs", 2)
    init_info_label(label_rule_cc_chasing_info, 9, "This is info about CC chasing.", 325, y, 150)

    y := y + 30
    init_label(label_keyswitches, "Keyswitches", 95, y, 95)

    menu_keyswitches -> help := "The list of configured keyswitches for the current rule. Up to 127 keyswitches are allowed per rule."
    move_and_set_width(menu_keyswitches, 200, y, 80)
    for i := 0 to MAX_KEYSWITCHES_PER_RULE - 1
        add_menu_item(menu_keyswitches, "", i)
    end for

    button_keyswitch_new -> help := "Create a new keyswitch, whose configuration is initialized to hopefully something intelligent based on context."
    set_text(button_keyswitch_new, "New")
    move_and_set_width(button_keyswitch_new, 290, y, 35)

    button_keyswitch_midi_learn -> help :="MIDI learn a keyswitch (note, CC, or program change).  Duplicates are prevented -- if you want duplicates, you need to manually configure them with the New button."
    set_text(button_keyswitch_midi_learn, "Learn")
    move_and_set_width(button_keyswitch_midi_learn, 330, y, 40)

    button_keyswitch_midi_learn_inc -> help := "Same as the Learn button, except the keyswitch config is initialized to values based on the relative distance between the current and newly learned keyswitches."
    set_text(button_keyswitch_midi_learn_inc, "Learn++")
    move_and_set_width(button_keyswitch_midi_learn_inc, 375, y, 50)

    button_keyswitch_midi_find -> help := "Find a keyswitch based on MIDI input. Don't forget to toggle this off when you're done searching!"
    set_text(button_keyswitch_midi_find, "MIDI Find")
    move_and_set_width(button_keyswitch_midi_find, 430, y, 55)

    button_keyswitch_remove -> help := "Remove the currently selected keyswitch from the rule."
    set_text(button_keyswitch_remove, "Remove")
    move_and_set_width(button_keyswitch_remove, 515, y, 50)

    // Remove Clear button for now.  Debating if this is worth having.
    hide(button_keyswitch_clear)
    //set_text(button_keyswitch_clear, "Clear All")
    //move_and_set_width(button_keyswitch_clear, 560, y, 50)
    //center(button_keyswitch_clear)


    y := y + 20
    init_label(label_rule_keyswitch, "Keyswitch", 135, y, 55)

    menu_rule_keyswitch_type -> help := "Defines the type of keyswitch: either a note, a CC event, or Program Change."
    move_and_set_width(menu_rule_keyswitch_type, 200, y, 40)
    add_menu_item(menu_rule_keyswitch_type, "Key", 0)
    add_menu_item(menu_rule_keyswitch_type, "CC", 1)
    add_menu_item(menu_rule_keyswitch_type, "Prog", 2)

    value_rule_keyswitch_key -> help := "Receiving this note on the rule's keyswitch channel will trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_key, 245, y, 40)
    set_text(value_rule_keyswitch_key, "")

    value_rule_keyswitch_cc -> help := "The CC number that must be received on the rule's keyswitch channel to trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_cc, 245, y, 35)
    set_text(value_rule_keyswitch_cc, "")
    init_label(label_rule_keyswitch_cc_slash, "/", 285, y, 15)
    value_rule_keyswitch_cc_value -> help := "The specific CC value that must be matched to trigger the keyswitch."
    move_and_set_width(value_rule_keyswitch_cc_value, 300, y, 35)
    set_text(value_rule_keyswitch_cc_value, "")

    value_rule_keyswitch_program -> help := "The program change number that will trigger the keyswitch when received on the rule's keyswitch channel."
    move_and_set_width(value_rule_keyswitch_program, 245, y, 35)
    set_text(value_rule_keyswitch_program, "")

    y := y + 20
    menu_rule_keyswitch_source_channel -> help := "Override the rule-default source channel. When this keyswitch is engaged, MIDI events on this channel will be routed to the target channel. Default means use the rule default above."
    init_label(label_rule_keyswitch_source_channel, "Source", 135, y, 55)
    move_and_set_width(menu_rule_keyswitch_source_channel, 200, y, 60)
    add_menu_item(menu_rule_keyswitch_source_channel, "Default", 0)
    add_menu_item(menu_rule_keyswitch_source_channel, "Omni", -1)
    init_channel_menu(menu_rule_keyswitch_source_channel, 16)

    y := y + 20
    menu_rule_keyswitch_target_channel -> help := "Override the rule-default target channel. When this keyswitch is engaged, MIDI events will be routed to this channel.  Null is a special case which blackholes all incoming MIDI events on the source channel when this keyswitch is active."
    init_label(label_rule_keyswitch_target_channel, "Target", 135, y, 55)
    move_and_set_width(menu_rule_keyswitch_target_channel, 200, y, 60)
    add_menu_item(menu_rule_keyswitch_target_channel, "Default", 0)
    add_menu_item(menu_rule_keyswitch_target_channel, "Null", -1)
    init_channel_menu(menu_rule_keyswitch_target_channel, 64)

    y := y + 20
    init_label(label_rule_keyswitch_flags, "Flags", 135, y, 55)
    switch_rule_keyswitch_flags_hold_notes -> help := "When enabled, note redirections (see keyswitch action) will be held until the next keyswitch activation. Useful for patches that engage functionality only while a particular note is pressed."
    set_text(switch_rule_keyswitch_flags_hold_notes, "Hold redirected notes until next keyswitch")
    move_and_set_width(switch_rule_keyswitch_flags_hold_notes, 200, y, 200)

    y := y + 20
    init_label(label_rule_keyswitch_action, "KS Action", 135, y, 55)

    menu_rule_keyswitch_action -> help := "Defines the action to take when the keyswitch is triggered. Block prevents the keyswitch from reaching the target channel. Passthrough will route the keyswitch as-is to the target. Redirect allows user-customizable translation to the target."
    move_and_set_width(menu_rule_keyswitch_action, 200, y, 80)
    add_menu_item(menu_rule_keyswitch_action, "Block", KEYSWITCH_ACTION_BLOCK)
    add_menu_item(menu_rule_keyswitch_action, "Passthrough", KEYSWITCH_ACTION_PASSTHROUGH)
    add_menu_item(menu_rule_keyswitch_action, "Redirect", KEYSWITCH_ACTION_REDIRECT)

    set_label_properties(label_rule_keyswitch_redirect_to, "to", 0, 1)
    set_bounds(label_rule_keyswitch_redirect_to, 285, y, 25)

    iterate_macro(configure_keyswitch_redirect_controls) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
    // The first redirect add/remove button is just a dummy/placeholder, so hide it.
    button_rule_keyswitch_addremove[0] -> hide := HIDE_WHOLE_CONTROL

    y := y - 80

    read_persistent_var(menu_rules)
    gui_update_for_selected_rule()
end macro

macro configure_keyswitch_redirect_controls(#n#)
    if #n# > 0
        button_rule_keyswitch_addremove#n# -> help := "Add or remove a redirection target"
        set_button_properties(button_rule_keyswitch_addremove[#n#], "+")
        button_rule_keyswitch_addremove[#n#] -> text_alignment := 1
        set_bounds(button_rule_keyswitch_addremove[#n#], 285, y, 25)
    end if

    menu_rule_keyswitch_redirect_type#n# -> help := "Defines the type of MIDI event the keyswitch will be redirected to. Either a note, CC event, or program change."
    set_bounds(menu_rule_keyswitch_redirect_type[#n#], 315, y, 40)
    add_menu_item(menu_rule_keyswitch_redirect_type#n#, "Key", 0)
    add_menu_item(menu_rule_keyswitch_redirect_type#n#, "CC", 1)
    add_menu_item(menu_rule_keyswitch_redirect_type#n#, "Prog", 2)

    value_rule_keyswitch_redirect_key#n# -> help := "The note the keyswitch will send to the target channel."
    move_and_set_width(value_rule_keyswitch_redirect_key#n#, 360, y, 40)
    set_text(value_rule_keyswitch_redirect_key#n#, "")

    value_rule_keyswitch_redirect_key_velocity#n# -> help := "The velocity of the note."
    init_label(label_rule_keyswitch_redirect_key_velocity#n#, "Velocity", 400, y, 45)
    center(label_rule_keyswitch_redirect_key_velocity#n#)
    move_and_set_width(value_rule_keyswitch_redirect_key_velocity#n#, 445, y, 35)
    set_text(value_rule_keyswitch_redirect_key_velocity#n#, "")

    value_rule_keyswitch_redirect_cc#n# -> help := "The CC number of the redirected MIDI event."
    move_and_set_width(value_rule_keyswitch_redirect_cc#n#, 360, y, 35)

    set_text(value_rule_keyswitch_redirect_cc#n#, "")
    init_label(label_rule_keyswitch_redirect_cc_slash#n#, "/", 395, y, 15)

    value_rule_keyswitch_redirect_cc_value#n# -> help := "The CC value of the redirected MIDI event."
    move_and_set_width(value_rule_keyswitch_redirect_cc_value#n#, 410, y, 35)
    set_text(value_rule_keyswitch_redirect_cc_value#n#, "")

    value_rule_keyswitch_redirect_program#n# -> help := "The program change number to send to the target channel."
    move_and_set_width(value_rule_keyswitch_redirect_program#n#, 360, y, 35)
    set_text(value_rule_keyswitch_redirect_program#n#, "")

    button_rule_keyswitch_redirect_midi_learn#n# -> help := "MIDI learn a redirection event."
    set_text(button_rule_keyswitch_redirect_midi_learn#n#, "MIDI Learn")
    move_and_set_width(button_rule_keyswitch_redirect_midi_learn#n#, 485, y, 60)

    y := y + 20
end macro

function init_channel_menu(menu, channels)
    for i := 1 to channels
        name := get_midi_channel_name(i)
        add_menu_item(menu, name, i)
    end for
end function

// CONVENIENCE MACROS

macro move(control, x, y)
    control -> pos_x := x
    control -> pos_y := y
end macro

macro move_and_set_width(control, x, y, w)
    move(control, x, y)
    control -> width := w
end macro

macro init_label(label, text, x, y, w)
    set_text(label, text)
    move_and_set_width(label, x, y, w)
    label -> text_alignment := 2
end macro

macro init_info_label(label, font, text, x, y, w)
    init_label(label, text, x, y, w)
    label -> hide := HIDE_PART_BG
    label -> text_alignment := 0
    label -> font_type := font
end macro

macro hide(control)
    control -> hide := HIDE_WHOLE_CONTROL
end macro

macro show(control)
    control -> hide := HIDE_PART_NOTHING
end macro

macro center(control)
    control -> text_alignment := 1
end macro

// GUI FUNCTIONS


// Returns the index of the selected rule in the UI
function gui_get_selected_rule() -> idx
    idx := menu_rules -> selected_item_idx
end function


// Returns the index of the selected keyswitch in the UI (within the context of the selected rule)
function gui_get_selected_keyswitch() -> idx
    idx := menu_keyswitches -> selected_item_idx
end function


// Given a channel number, update the given label with the human readable channel name.
function _gui_set_channel_info_label(label, channel)
    name := get_midi_channel_name(channel)
    set_text(label, name)
end function


// Adjusts all the UI elements to reflect the currently selected item in the rules menu.
function gui_update_for_selected_rule()
    rule := gui_get_selected_rule()
    text_rule_name := rules[rule].name

    menu_global_cc_hanging := global_config[GLOBAL_CONFIG_CC_HANGING]
    menu_rule_keyswitch_channel := rules[rule].config[RULE_KEYSWITCH_CHANNEL]
    menu_rule_source_channel := rules[rule].config[RULE_SOURCE_CHANNEL]
    menu_rule_target_channel := rules[rule].config[RULE_TARGET_CHANNEL]
    menu_rule_cc_chasing := rules[rule].config[RULE_CC_CHASING]
    if menu_rule_cc_chasing = 2
        set_text(label_rule_cc_chasing_info, "Chases CCs 1, 2, 11, 64-69")
    else
        set_text(label_rule_cc_chasing_info, "")
    end if

    button_rule_bypass := 1 - rules[rule].config[RULE_ENABLED]
    menu_keyswitches := 0
       for i := 0 to MAX_KEYSWITCHES_PER_RULE - 1
           ks := rules[rule].keyswitch[i].evcode
           if ks # KEYSWITCH_UNDEFINED
               name := get_keyswitch_name(ks)
               set_menu_item_str(get_ui_id(menu_keyswitches), i, name)
               set_menu_item_visibility(get_ui_id(menu_keyswitches), i, 1)
           else
               set_menu_item_str(get_ui_id(menu_keyswitches), i, "<empty>")
            if i > 0
                set_menu_item_visibility(get_ui_id(menu_keyswitches), i, 0)
            end if
           end if
    end for
    gui_update_for_selected_keyswitch()
end function


// Set visibility of all controls in the keyswitch section by context of the keyswitch configuration.
function gui_set_keyswitch_section_visibility(rule, idx, ks, action)
    // section control, ks note controls, ks cc controls, ks program controls,
    //   section info label, general redirect controls, key redirect controls,
    //   CC redirect controls, Prog redirect controls
    declare params[9]
    macro reset_params()
        for j := 0 to 8
            params[j] := HIDE_WHOLE_CONTROL
        end for
    end macro
    reset_params()
    if ks # KEYSWITCH_UNDEFINED
        params[0] := HIDE_PART_NOTHING
        params[4] := HIDE_PART_BG
        if ks < 128
            params[1] := HIDE_PART_NOTHING
        else if ks < 256
            params[3] := HIDE_PART_NOTHING
        else
            params[2] := HIDE_PART_NOTHING
        end if
    end if

    label_rule_keyswitch -> hide := params[0]
    menu_rule_keyswitch_type -> hide := params[0]
    label_rule_keyswitch_action -> hide := params[0]
    menu_rule_keyswitch_action -> hide := params[0]

    value_rule_keyswitch_key -> hide := params[1]
    value_rule_keyswitch_cc -> hide := params[2]
    label_rule_keyswitch_cc_slash -> hide := params[2]
    value_rule_keyswitch_cc_value -> hide := params[2]
    value_rule_keyswitch_program -> hide := params[3]

    label_rule_keyswitch_source_channel -> hide := params[0]
    menu_rule_keyswitch_source_channel -> hide := params[4]
    label_rule_keyswitch_target_channel -> hide := params[0]
    menu_rule_keyswitch_target_channel -> hide := params[4]
    label_rule_keyswitch_flags -> hide := params[0]
    switch_rule_keyswitch_flags_hold_notes -> hide := params[4]

    for i := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
        // Initialize show/hide parameters based on keyswitch config context
        reset_params()
        evcode := rules[rule].keyswitch[idx].redirects[i].evcode
        if action = KEYSWITCH_ACTION_REDIRECT
            if evcode # KEYSWITCH_UNDEFINED
                params[0] := HIDE_PART_NOTHING
                if evcode < 128
                    params[1] := HIDE_PART_NOTHING
                else if evcode < 256
                    params[3] := HIDE_PART_NOTHING
                else
                    params[2] := HIDE_PART_NOTHING
                end if
            end if
        end if

        if i = 0
            label_rule_keyswitch_redirect_to -> hide := params[0]
        else
            if evcode # KEYSWITCH_UNDEFINED and action = KEYSWITCH_ACTION_REDIRECT
                set_button_properties(button_rule_keyswitch_addremove[i], "-")
                button_rule_keyswitch_addremove[i] -> hide := HIDE_PART_NOTHING
            else
                set_button_properties(button_rule_keyswitch_addremove[i], "+")
                // If the previous keyswitch redirect is defined, show the button.
                if rules[rule].keyswitch[idx].redirects[i - 1].evcode # KEYSWITCH_UNDEFINED and ...
                    action = KEYSWITCH_ACTION_REDIRECT
                    button_rule_keyswitch_addremove[i] -> hide := HIDE_PART_NOTHING
                else
                    button_rule_keyswitch_addremove[i] -> hide := HIDE_WHOLE_CONTROL
                end if
            end if
        end if

        menu_rule_keyswitch_redirect_type[i] -> hide := params[0]
        value_rule_keyswitch_redirect_key[i] -> hide := params[1]
        label_rule_keyswitch_redirect_key_velocity[i] -> hide := params[1]
        value_rule_keyswitch_redirect_key_velocity[i] -> hide := params[1]

        value_rule_keyswitch_redirect_cc[i] -> hide := params[2]
        label_rule_keyswitch_redirect_cc_slash[i] -> hide := params[2]
        value_rule_keyswitch_redirect_cc_value[i] -> hide := params[2]

        value_rule_keyswitch_redirect_program[i] -> hide := params[3]
        button_rule_keyswitch_redirect_midi_learn[i] -> hide := params[0]
    end for
end function

function gui_update_keyswitch_name()
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    ks := rules[rule].keyswitch[idx].evcode
    name := get_keyswitch_name(ks)
    set_menu_item_str(get_ui_id(menu_keyswitches), idx, name)
end function

// Adjusts all the UI elements to reflect the currently selected keyswitch (for the current rule)
function gui_update_for_selected_keyswitch()
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    ks := rules[rule].keyswitch[idx].evcode
    action := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_ACTION]
    flag := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_FLAGS]

    menu_rule_keyswitch_source_channel := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_SOURCE_CHANNEL]
    menu_rule_keyswitch_target_channel := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_TARGET_CHANNEL]
    switch_rule_keyswitch_flags_hold_notes := flag .and. RULE_KEYSWITCH_FLAGS

    gui_set_keyswitch_section_visibility(rule, idx, ks, action)

    if ks < 128
        menu_rule_keyswitch_type := 0
        value_rule_keyswitch_key := ks
    else if ks < 256
        menu_rule_keyswitch_type := 2
        value_rule_keyswitch_program := ks - 128
    else if ks # KEYSWITCH_UNDEFINED
        menu_rule_keyswitch_type := 1
        value_rule_keyswitch_cc := ks / 128 - 128
        value_rule_keyswitch_cc_value := ks mod 128
    end if

    menu_rule_keyswitch_action := action

    if action = KEYSWITCH_ACTION_REDIRECT
        macro update_keyswitch_redirect(#n#)
            evcode := rules[rule].keyswitch[idx].redirects[#n#].evcode
            if evcode < 128
                velocity := rules[rule].keyswitch[idx].redirects[#n#].velocity
                value_rule_keyswitch_redirect_key#n# := evcode
                menu_rule_keyswitch_redirect_type#n# := 0
                value_rule_keyswitch_redirect_key_velocity#n# := velocity
            else if evcode < 256
                menu_rule_keyswitch_redirect_type#n# := 2
                value_rule_keyswitch_redirect_program#n# := evcode - 128
            else if evcode # KEYSWITCH_UNDEFINED
                menu_rule_keyswitch_redirect_type#n# := 1
                value_rule_keyswitch_redirect_cc#n# := evcode / 128 - 128
                value_rule_keyswitch_redirect_cc_value#n# := evcode mod 128
            end if
        end macro
        iterate_macro(update_keyswitch_redirect) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
    end if
end function


// Sets the given config parameter for the currently selected rule.
function gui_set_selected_rule_config(config, value)
    rule := gui_get_selected_rule()
    rules[rule].config[config] := value
    need_maps_rebuild := 1
end function


// Clears all active routes and informs user via a message.  Must be called when a UI
//   element is changed that would invalidate the current routes.
function gui_clear_active_routes_for_all_channels()
    for j := 0 to NUM_SOURCE_CHANNELS - 1
        clear_active_routes_for_channel(j)
    end for
    message("Active keyswitches cleared due to rule change.  Keyswitches must be retriggered.")
end function


// Adds the given keyswitch number to the currently selected rule.  Triggered by MIDI learn and the
// New button.
function gui_append_keyswitch_to_selected_rule(ks)
    rule := gui_get_selected_rule()

    if ks # KEYSWITCH_UNDEFINED
        // Do not allow MIDI Learn to create duplicates of a keyswitch. (Though
        //   that can be done manually.)
        idx := get_keyswitch_idx_for_rule(rule, ks)
    else
        idx := -1
    end if

    if idx = -1
        // Determine the currently selected keyswitch in the GUI for later.
        idx := gui_get_selected_keyswitch()
        count := get_num_keyswitches_for_rule(rule)
        if ks = KEYSWITCH_UNDEFINED
            if count > 0
                ks := rules[rule].keyswitch[idx].evcode + 1
            else
                // No existing keyswitches, use first note.
                ks := 0
            end if
        end if

        if count < MAX_KEYSWITCHES_PER_RULE
            name := get_keyswitch_name(ks)
            set_menu_item_str(get_ui_id(menu_keyswitches), count, name)
            set_menu_item_visibility(get_ui_id(menu_keyswitches), count, 1)
            rules[rule].keyswitch[count].evcode := ks
            menu_keyswitches := count

            if count > 0
                // Clone some config from the currently selected keyswitch
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_ACTION] := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_ACTION]
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_SOURCE_CHANNEL] := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_SOURCE_CHANNEL]
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_TARGET_CHANNEL] := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_TARGET_CHANNEL]

                // If the currently selected keyswitch we're cloning is a redirect and the Learn++
                // button was pressed, rather than cloning the redirect config directly, measure the
                // distance between the new keyswitch and the currently selected keyswitch and
                // adjust the redirection based on the distance.
                action := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_ACTION]
                if action = KEYSWITCH_ACTION_REDIRECT
                    if button_keyswitch_midi_learn_inc = 1
                        offset := ks - rules[rule].keyswitch[idx].evcode
                    else
                        offset := 0
                    end if

                    for i := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
                        evcode := rules[rule].keyswitch[idx].redirects[i].evcode
                        if evcode # KEYSWITCH_UNDEFINED
                            // Now configure the new keyswitch with the adjusted redirect and the
                            // source/target channels of the cloned keyswitch.
                            rules[rule].keyswitch[count].redirects[i].evcode := evcode + offset
                            value := rules[rule].keyswitch[idx].redirects[i].velocity
                            rules[rule].keyswitch[count].redirects[i].velocity := value
                        else
                            rules[rule].keyswitch[count].redirects[i].evcode := KEYSWITCH_UNDEFINED
                        end if
                    end for
                end if
            else
                // Initialize new keyswitch (not cloned) to blocked, all source channels,
                // rule default target channel.
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_ACTION] := KEYSWITCH_ACTION_BLOCK
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_SOURCE_CHANNEL] := 0
                rules[rule].keyswitch[count].config[RULE_KEYSWITCH_TARGET_CHANNEL] := 0
                for i := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
                    rules[rule].keyswitch[count].redirects[i].evcode := KEYSWITCH_UNDEFINED
                end for
            end if
            call gui_update_for_selected_keyswitch
            message("Added keyswitch " & name & " to rule " & rules[rule].name & " at " & count)
        else
            message("ERROR: too many keyswitches for this rule, can't add.")
        end if
        need_maps_rebuild := 1
    else
        // Keyswitch already exists, so select it in UI instead
        menu_keyswitches := idx
        call gui_update_for_selected_keyswitch
    end if
end function


// Removes all keyswitches for the current rule.
function gui_clear_keyswitches_for_selected_rule()
    rule := gui_get_selected_rule()
    menu_keyswitches := 0
    for i := 0 to MAX_KEYSWITCHES_PER_RULE - 1
        rules[rule].keyswitch[i].evcode := KEYSWITCH_UNDEFINED
        rules[rule].keyswitch[i].config[RULE_KEYSWITCH_ACTION] := KEYSWITCH_ACTION_BLOCK
        set_menu_item_str(get_ui_id(menu_keyswitches), i, "<empty>")
        if i > 0
            set_menu_item_visibility(get_ui_id(menu_keyswitches), i, 0)
        end if
    end for
    call gui_clear_active_routes_for_all_channels
    call gui_update_for_selected_keyswitch
end function


// Sets the given config parameter for the currently selected keyswitch.
function gui_set_selected_keyswitch_config(config, value)
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    // If setting the keyswitch action to redirect, then ensure the first
    // keyswitch redirect is initialized.
    if config = RULE_KEYSWITCH_ACTION and value = KEYSWITCH_ACTION_REDIRECT
        if rules[rule].keyswitch[idx].redirects[0]._raw = KEYSWITCH_UNDEFINED
            rules[rule].keyswitch[idx].redirects[0].evcode := 0
        end if
    end if
    rules[rule].keyswitch[idx].config[config] := value
end function

// Sets a redirect for the currently selected keyswitch.
function gui_set_selected_keyswitch_config_redirect(n, ks, velocity)
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    if ks >= 0
        rules[rule].keyswitch[idx].redirects[n].evcode := ks
    end if
    if velocity >= 0
        rules[rule].keyswitch[idx].redirects[n].velocity := velocity
    end if
end function

// Sets the given config parameter for the currently selected keyswitch.
function gui_set_selected_keyswitch_config_flags(flag, state)
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    value := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_FLAGS] .and. .not. flag
    if state # 0
        value := value .or. flag
    end if
    rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_FLAGS] := value
end function


// Updates the UI to show the given keyswitch as selected.  Triggered by MIDI Find.
function gui_set_selected_keyswitch_by_ks(ks)
    rule := gui_get_selected_rule()
    idx := get_keyswitch_idx_for_rule(rule, ks)
    if idx # -1
        menu_keyswitches := idx
        call gui_update_for_selected_keyswitch
    else
        name := get_keyswitch_name(ks)
        message("Keyswitch " & name & " not found for this rule")
    end if
end function



// Configures the active keyswitch parameters from the current UI settings
function gui_set_selected_keyswitch_from_ui
    if menu_rule_keyswitch_type = 0
         // Key
        ks := value_rule_keyswitch_key
    else if menu_rule_keyswitch_type = 2
        // Program
        ks := 128 + value_rule_keyswitch_program
    else
        // CC
        ks := 128*128 + value_rule_keyswitch_cc * 128 + value_rule_keyswitch_cc_value
    end if
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    rules[rule].keyswitch[idx].evcode := ks
    call gui_update_for_selected_keyswitch
end function


function clear_redirect_midi_learn_buttons
    macro _clear_redirect_midi_learn_buttons(#n#)
        button_rule_keyswitch_redirect_midi_learn#n# := 0
    end macro
    iterate_macro(_clear_redirect_midi_learn_buttons) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
    keyswitch_redirect_midi_learn_index := -1
    button_keyswitch_midi_find := 0
    button_keyswitch_midi_learn_inc := 0
    button_keyswitch_midi_learn := 0

end function

// Configures the redirect keyswitch for the currently selected keyswitch.  Triggered
//   by keyswitch MIDI Learn.
function gui_set_selected_keyswitch_redirect(ks, value)
    gui_set_selected_keyswitch_config_redirect(keyswitch_redirect_midi_learn_index, ks, value)
    call clear_redirect_midi_learn_buttons
    call gui_update_for_selected_keyswitch
    need_maps_rebuild := 1
end function


// Configures the active keyswitch redirection parameters from the current UI settings
function gui_set_selected_keyswitch_redirect_from_ui
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    macro update_keyswitch_config_redirect(#n#)
        if menu_rule_keyswitch_redirect_type[#n#] -> hide = HIDE_WHOLE_CONTROL
            // If the keyswitch type menu is hidden, then keyswitch is undefined.
            ks := KEYSWITCH_UNDEFINED
        else if menu_rule_keyswitch_redirect_type#n# = 0
             // Key
            ks := value_rule_keyswitch_redirect_key#n#
        else if menu_rule_keyswitch_redirect_type#n# = 1
            // CC
            ks := 128*128 + value_rule_keyswitch_redirect_cc#n# * 128 + value_rule_keyswitch_redirect_cc_value#n#
        else if menu_rule_keyswitch_redirect_type#n# = 2
            // Program
            ks := 128 + value_rule_keyswitch_redirect_program#n#
        else
            ks := KEYSWITCH_UNDEFINED
        end if
        rules[rule].keyswitch[idx].redirects[#n#].evcode := ks
        rules[rule].keyswitch[idx].redirects[#n#].velocity := value_rule_keyswitch_redirect_key_velocity#n#
    end macro
    iterate_macro(update_keyswitch_config_redirect) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1
end function


// EVENT HANDLERS

on ui_control(menu_global_cc_hanging)
    global_config[GLOBAL_CONFIG_CC_HANGING] := menu_global_cc_hanging
end on

// Selected rule changed
on ui_control(menu_rules)
    call gui_update_for_selected_rule
end on


// Add Rule button clicked
on ui_control(button_add)
    // Find empty available slot for rule
    idx := get_next_rule_idx()
    if idx = -1
        message("Can't add a new rule, already at limit of " & MAX_GUI_RULES)
    else
        initialize_rule(idx, "New Rule")
        set_menu_item_str(get_ui_id(menu_rules), idx, rules[idx].name)
        set_menu_item_visibility(get_ui_id(menu_rules), idx, 1)
        menu_rules := idx
        call gui_update_for_selected_rule
    end if
    button_add := 0
end on


// Remove Rule button clicked
on ui_control(button_remove)
    rule := gui_get_selected_rule()
    // Determine closest adjacent rule to select next.
    target := -1
    for i := 0 to MAX_GUI_RULES - 1
        if rules[i].config[RULE_DEFINED] = 1 and i # rule and ...
         (target = -1 or abs(rule - i) < abs(rule - target))
            target := i
        end if
    end for
    if target = -1
        // This is the last rule, so rather than delete it, clear/reset it instead.
        initialize_rule(rule, "Your first rule - rename me!")
        set_menu_item_str(get_ui_id(menu_rules), idx, rules[idx].name)
        call gui_update_for_selected_rule
    else
        rules[rule].config[RULE_DEFINED] := 0
        // TODO: vacuum rules list
        menu_rules := target
        set_menu_item_visibility(get_ui_id(menu_rules), rule, 0)
        call gui_update_for_selected_rule
        message("")
    end if
    button_remove := 0
end on

on ui_control(button_rule_clone)
    rule := gui_get_selected_rule()
    if rule >= 0
        // Find empty available slot for rule
        idx := get_next_rule_idx()
        if idx = -1
            message("Can't add a new rule, already at limit of " & MAX_GUI_RULES)
        else
            copy_rule(rule, idx)
            rules[idx].name := "CLONE - " & rules[rule].name
            set_menu_item_str(get_ui_id(menu_rules), idx, rules[idx].name)
            set_menu_item_visibility(get_ui_id(menu_rules), idx, 1)
            menu_rules := idx
            call gui_update_for_selected_rule
        end if
    end if
    button_rule_clone := 0
end on


// Rule name text entry changed
on ui_control(text_rule_name)
    rule := gui_get_selected_rule()
    rules[rule].name := text_rule_name
    set_menu_item_str(get_ui_id(menu_rules), rule, text_rule_name)
end on


// Rule Bypass button clicked
on ui_control(button_rule_bypass)
    gui_set_selected_rule_config(RULE_ENABLED, 1 - button_rule_bypass)
    call gui_clear_active_routes_for_all_channels
end on


// Keyswitch channel menu changed
on ui_control(menu_rule_keyswitch_channel)
    gui_clear_active_routes_for_all_channels()
    gui_set_selected_rule_config(RULE_KEYSWITCH_CHANNEL, menu_rule_keyswitch_channel)
end on


// Source channel menu  changed
on ui_control(menu_rule_source_channel)
    gui_clear_active_routes_for_all_channels()
    gui_set_selected_rule_config(RULE_SOURCE_CHANNEL, menu_rule_source_channel)
end on


// Target channel menu  changed
on ui_control(menu_rule_target_channel)
    gui_clear_active_routes_for_all_channels()
    gui_set_selected_rule_config(RULE_TARGET_CHANNEL, menu_rule_target_channel)
end on

// CC chasing menu changed
on ui_control(menu_rule_cc_chasing)
    gui_set_selected_rule_config(RULE_CC_CHASING, menu_rule_cc_chasing)
    call gui_update_for_selected_rule
end on

// Selected keyswitch changed
on ui_control(menu_keyswitches)
    call gui_update_for_selected_keyswitch
end on


// Keyswitch New button clicked
on ui_control(button_keyswitch_new)
    ks := KEYSWITCH_UNDEFINED
    gui_append_keyswitch_to_selected_rule(ks)
    button_keyswitch_new := 0
end on


// Keyswitch MIDI Learn button clicked
on ui_control(button_keyswitch_midi_learn)
    if button_keyswitch_midi_learn = 0
        need_maps_rebuild := 1
    else
        call clear_redirect_midi_learn_buttons
        button_keyswitch_midi_learn := 1
    end if
end on


// Keyswitch MIDI Learn++ button clicked
on ui_control(button_keyswitch_midi_learn_inc)
    if button_keyswitch_midi_learn_inc = 0
        need_maps_rebuild := 1
    else
        call clear_redirect_midi_learn_buttons
        button_keyswitch_midi_learn_inc := 1
    end if
end on

// Keyswitch Remove button clicked
on ui_control(button_keyswitch_remove)
    rule := gui_get_selected_rule()
    ks := gui_get_selected_keyswitch()
    count := get_num_keyswitches_for_rule(rule)

    if ks > 0 and ks = count - 1
        menu_keyswitches := count - 2
    end if

    while ks < MAX_KEYSWITCHES_PER_RULE
        rules[rule].keyswitch[ks].evcode := rules[rule].keyswitch[ks + 1].evcode
        rules[rule].keyswitch[ks + 1].evcode := KEYSWITCH_UNDEFINED
        name := get_menu_item_str(get_ui_id(menu_keyswitches), ks + 1)
        set_menu_item_str(get_ui_id(menu_keyswitches), ks, name)
        for i := 0 to MAX_CONFIG_PER_KEYSWITCH - 1
            rules[rule].keyswitch[ks].config[i] := rules[rule].keyswitch[ks + 1].config[i]
            rules[rule].keyswitch[ks + 1].config[i] := -1
        end for
        ks := ks + 1
    end while

    // Hide the last item that was in the list
    set_menu_item_str(get_ui_id(menu_keyswitches), count - 1, "<empty>")
    set_menu_item_visibility(get_ui_id(menu_keyswitches), count - 1, 0)
    call gui_update_for_selected_keyswitch
    button_keyswitch_remove := 0
    need_maps_rebuild := 1
end on


// Keyswitch Redirect MIDI Learn button clicked
on ui_control(button_keyswitch_midi_find)
    if button_keyswitch_midi_find = 1
        call clear_redirect_midi_learn_buttons
        button_keyswitch_midi_find := 1
    end if
end on


// Keyswitch Clear button clicked
on ui_control(button_keyswitch_clear)
    call gui_clear_keyswitches_for_selected_rule
    need_maps_rebuild := 1
    button_keyswitch_clear := 0
end on

// Keyswitch redirect type menu (key or CC) changed
on ui_control(menu_rule_keyswitch_type)
    if menu_rule_keyswitch_type = 0
         // FIXME: get next available key
        ks := 0
    else if menu_rule_keyswitch_type = 2
        // FIXME: get next available program
        ks := 128
    else
        // FIXME: get next available CC
        ks := 130*128 // CC-2 value 0
    end if
    rule := gui_get_selected_rule()
    idx := gui_get_selected_keyswitch()
    rules[rule].keyswitch[idx].evcode := ks
    call gui_update_for_selected_keyswitch
    call gui_update_keyswitch_name
end on


// Keyswitch redirect to note value changed
on ui_control(value_rule_keyswitch_key)
    call gui_set_selected_keyswitch_from_ui
    call gui_update_keyswitch_name
    need_maps_rebuild := 1
end on

// Keyswitch redirect to CC number changed
on ui_control(value_rule_keyswitch_cc)
    call gui_set_selected_keyswitch_from_ui
    call gui_update_keyswitch_name
    need_maps_rebuild := 1
end on


// Keyswitch redirect to CC value
on ui_control(value_rule_keyswitch_cc_value)
    call gui_set_selected_keyswitch_from_ui
    call gui_update_keyswitch_name
    need_maps_rebuild := 1
end on

// Keyswitch redirect to CC value
on ui_control(value_rule_keyswitch_program)
    call gui_set_selected_keyswitch_from_ui
    call gui_update_keyswitch_name
    need_maps_rebuild := 1
end on


// Keyswitch action menu (block, passthrough, redirect) changed
on ui_control(menu_rule_keyswitch_action)
    gui_set_selected_keyswitch_config(RULE_KEYSWITCH_ACTION, menu_rule_keyswitch_action)
    call gui_update_for_selected_keyswitch
end on


macro add_keyswitch_redirect_callbacks(#n#)
    on ui_control(button_rule_keyswitch_addremove#n#)
        rule := gui_get_selected_rule()
        idx := gui_get_selected_keyswitch()
        value := rules[rule].keyswitch[idx].redirects[#n#]._raw
        if value = KEYSWITCH_UNDEFINED
            // Duplicate previous keyswitch
            rules[rule].keyswitch[idx].redirects[#n#]._raw := rules[rule].keyswitch[idx].redirects[#n# - 1]._raw
        else
            // Move up everything below this keyswitch redirect
            for i := #n# to MAX_REDIRECTS_PER_KEYSWITCH - 2
                rules[rule].keyswitch[idx].redirects[i]._raw := rules[rule].keyswitch[idx].redirects[i + 1]._raw
                rules[rule].keyswitch[idx].redirects[i + 1]._raw := KEYSWITCH_UNDEFINED
            end for
        end if
        call gui_update_for_selected_keyswitch
        button_rule_keyswitch_addremove#n# := 0
    end on

    // Keyswitch redirect type menu (key or CC) changed
    on ui_control(menu_rule_keyswitch_redirect_type#n#)
        velocity := -1
        if menu_rule_keyswitch_redirect_type#n# = 0
            evcode := 0   { C-2 }
            velocity := 127
        else if menu_rule_keyswitch_redirect_type#n# = 2
            evcode := 128 { Prog 0 }
        else
            evcode := 130*128 { CC-2 value 0 }
        end if
        gui_set_selected_keyswitch_config_redirect(#n#, evcode, velocity)
        call gui_update_for_selected_keyswitch
    end on

    // Keyswitch redirect to note value changed
    on ui_control(value_rule_keyswitch_redirect_key#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on

    // Keyswitch redirect to note velocity value changed
    on ui_control(value_rule_keyswitch_redirect_key_velocity#n#)
        gui_set_selected_keyswitch_config_redirect(#n#, -1, value_rule_keyswitch_redirect_key_velocity#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on


    // Keyswitch redirect to CC number changed
    on ui_control(value_rule_keyswitch_redirect_cc#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on


    // Keyswitch redirect to CC value
    on ui_control(value_rule_keyswitch_redirect_cc_value#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on

    // Keyswitch redirect to CC value
    on ui_control(value_rule_keyswitch_redirect_program#n#)
        call gui_set_selected_keyswitch_redirect_from_ui
    end on

    // Keyswitch Redirect MIDI Learn button clicked
    on ui_control(button_rule_keyswitch_redirect_midi_learn#n#)
        if keyswitch_redirect_midi_learn_index = #n#
            button_rule_keyswitch_redirect_midi_learn#n# := 0
            keyswitch_redirect_midi_learn_index := -1
        else
            call clear_redirect_midi_learn_buttons
            button_rule_keyswitch_redirect_midi_learn#n# := 1
            keyswitch_redirect_midi_learn_index := #n#
        end if
    end on
end macro
iterate_macro(add_keyswitch_redirect_callbacks) := 0 to MAX_GUI_REDIRECTS_PER_KEYSWITCH - 1


// Keyswitch source channel value changed
on ui_control(menu_rule_keyswitch_source_channel)
    gui_set_selected_keyswitch_config(RULE_KEYSWITCH_SOURCE_CHANNEL, menu_rule_keyswitch_source_channel)
    need_maps_rebuild := 1
    call gui_clear_active_routes_for_all_channels
end on

// Keyswitch target channel value changed
on ui_control(menu_rule_keyswitch_target_channel)
    gui_set_selected_keyswitch_config(RULE_KEYSWITCH_TARGET_CHANNEL, menu_rule_keyswitch_target_channel)
    need_maps_rebuild := 1
    call gui_clear_active_routes_for_all_channels
end on

// Keyswitch flags changed
on ui_control(switch_rule_keyswitch_flags_hold_notes)
    gui_set_selected_keyswitch_config_flags(KEYSWITCH_FLAG_HOLD_NOTES, switch_rule_keyswitch_flags_hold_notes)
end on