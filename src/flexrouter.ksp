import "utils.ksp"
import "gui.ksp"

on init
    set_script_title("FlexRouter 2.2.2")
    declare const DEBUG := 1
    declare const CONFIG_VERSION := 4

    declare const MAX_GLOBAL_CONFIG := 32
    // Version for saved data.  This will be the first piece of data persisted.
    declare const GLOBAL_CONFIG_VERSION := 0
    // 0 = Allow CC hanging, 1 = Prevent hanging for all CCs, 2 = prevent CC hanging for CC 2/64
    declare const GLOBAL_CONFIG_CC_HANGING := 1

    // Max number of rules allowed per data structure.
    declare const MAX_RULES := 32
    // Max number of rules the GUI allows to be configured.
    declare const MAX_GUI_RULES := 16
    declare const NUM_SOURCE_CHANNELS := 16
    declare const MAX_KEYSWITCHES_PER_RULE := 128
    declare const MAX_CONFIG_PER_RULE := 16
    declare const MAX_CONFIG_PER_KEYSWITCH := 8
    declare const MAX_REDIRECTS_PER_KEYSWITCH := 8
    define MAX_GUI_REDIRECTS_PER_KEYSWITCH := 4

    declare const KEYSWITCH_UNDEFINED := 0xffff

    // These constants  apply to the rule config parameter.
    // e.g. rules[idx].config[RULE_DEFINED]

    // 1 if the rule is defined, 0 if not and is a free slot for new rules.
    declare const RULE_DEFINED := 0
    // 1 if the rule is enabled, 0 if bypassed.
    declare const RULE_ENABLED := 1
    // The MIDI channel that keyswitches will be received on for this rule.  Value is as is shown
    // in the GUI, so MIDI channel 1 is stored as 1.
    declare const RULE_KEYSWITCH_CHANNEL := 2

    // The default target MIDI channel for the rule's keyswitches.  For keyswitches using the
    // default target, once activated, subsequent events received on the keyswitch's configured
    // source channel will be diverted to this target channel.  MIDI channel 1 is stored as 1.
    declare const RULE_TARGET_CHANNEL := 3

    // The default source MIDI channel for the rule's keyswitches.  For keyswitches using the
    // default source, once activated, only events coming on this channel will be routed to the
    // target channel. MIDI channel 1 is stored as 1.
    declare const RULE_SOURCE_CHANNEL := 4

    // Defines the CC chasing behaviour when keyswitches are triggered under the rule.
    // 0 = no chasing, 1 = chase all CCs, 2 = chase "common" (1, 2, 11, 64-69).
    declare const RULE_CC_CHASING := 5

    // These constants apply to the keyswitch config parameter.
    // e.g. rules[idx].keyswitch_config[ksidx, RULE_KEYSWITCH_SOURCE_CHANNEL ]

     // 0: block, 1: passthrough, 2: redirect (in which case keyswitch_redirects defines targets)
    declare const RULE_KEYSWITCH_ACTION := 0
    declare const KEYSWITCH_ACTION_BLOCK := 0
    declare const KEYSWITCH_ACTION_PASSTHROUGH := 1
    declare const KEYSWITCH_ACTION_REDIRECT := 2

    // A bitmap of flags for this keyswitch.
    declare const RULE_KEYSWITCH_FLAGS := 1
    declare const KEYSWITCH_FLAG_HOLD_NOTES := 1
    declare const KEYSWITCH_FLAG_IGNORE_ROUTING := 2


    // When the keyswitch is activated, non-keyswitch MIDI events received on this channel will be
    // redirected to the target channel.   A value of 0 means to use the rule default source,
    // -1 means all channels (omni), otherwise refers to a specific channel starting at 1.
    declare const RULE_KEYSWITCH_SOURCE_CHANNEL := 2

    // Target channel for this keyswitch.  A value of 0 means to use the rule default target,
    // -1 means to blackhole (null) the events, otherwise indicates the specific target channel
    // starting at 1.
    declare const RULE_KEYSWITCH_TARGET_CHANNEL := 3

    // For note-based keyswitches, defines the velocity range the keyswitch applies to.
    // Encoded such that the low 8 bits are the min velocity, and the next byte is max velocity.
    declare const RULE_KEYSWITCH_VELOCITY_RANGE := 4
    declare const VELOCITY_RANGE_DEFAULT := 0x7f00 // 0-127



    family rules
        // Rules arrays can have gaps caused by removing rules.  Use RULE_DEFINED config
        // to determine if the rule is set.
        declare !_name[MAX_RULES]
        declare _config[MAX_RULES * MAX_CONFIG_PER_RULE] := (0)
        // In contrast, for a given rule, the keyswitch arrays _don't_ have gaps.  They are
        // closed when keyswitches are removed.
        declare _keyswitches[MAX_RULES * MAX_KEYSWITCHES_PER_RULE] := (KEYSWITCH_UNDEFINED)
        declare _keyswitch_config[MAX_RULES * MAX_KEYSWITCHES_PER_RULE * MAX_CONFIG_PER_KEYSWITCH] := (-1)
        // Low 16 bits contains ks value, next 8 bits contains velocity.  High 8 bits is reserved.
        declare _keyswitch_redirects[MAX_RULES * MAX_KEYSWITCHES_PER_RULE * MAX_REDIRECTS_PER_KEYSWITCH] := (KEYSWITCH_UNDEFINED)

        property name
            function get(rule) -> result
                result := rules._name[rule]
            end function
            function set(rule, value)
                rules._name[rule] := value
                set_strings_16(_rules_name, rule, value)
            end function
        end property

        property config
            function get(rule, param) -> result
                result := rules._config[rule * MAX_CONFIG_PER_RULE + param]
            end function
            function set(rule, param, value)
                rules._config[rule * MAX_CONFIG_PER_RULE + param] := value
            end function
        end property


        family keyswitch
            // An "evcode" is a custom 16-bit encoding of a MIDI event.  See below for description.
            //
            // For CC keyswitches, a value of 0 in the evcode indicates that the value range
            // must be checked.  It could actually be a single CC value 0, in which case the
            // value range will be 0-0.  Note that even in the case of non-range CCs (i.e.
            // single value), the value range will be set properly.
            property evcode
                function get(rule, ks) -> result
                    result := rules._keyswitches[rule * MAX_KEYSWITCHES_PER_RULE + ks]
                end function
                function set(rule, ks, value)
                    rules._keyswitches[rule * MAX_KEYSWITCHES_PER_RULE + ks] := value
                end function
            end property

            family velocity
                property min
                    function get(rule, ks) -> result
                        result := rules[rule].keyswitch[ks].velocity._raw .and. 0xff
                    end function
                    function set(rule, ks, value)
                        rules[rule].keyswitch[ks].velocity._raw := (rules[rule].keyswitch[ks].velocity._raw .and. 0xff00) + value
                    end function
                end property
                property max
                    function get(rule, ks) -> result
                        result := sh_right(rules[rule].keyswitch[ks].velocity._raw, 8) .and. 0xff
                    end function
                    function set(rule, ks, value)
                        rules[rule].keyswitch[ks].velocity._raw := (rules[rule].keyswitch[ks].velocity._raw .and. 0xff) + sh_left(value, 8)
                    end function
                end property
                property _raw
                    function get(rule, ks) -> result
                        result := rules[rule].keyswitch[ks].config[RULE_KEYSWITCH_VELOCITY_RANGE]
                    end function
                    function set(rule, ks, value)
                        rules[rule].keyswitch[ks].config[RULE_KEYSWITCH_VELOCITY_RANGE] := value
                    end function
                end property
            end family

            property config
                function get(rule, ks, param) -> result
                    result := rules._keyswitch_config[rule * MAX_KEYSWITCHES_PER_RULE * MAX_CONFIG_PER_KEYSWITCH + ks * MAX_CONFIG_PER_KEYSWITCH + param]
                end function
                function set(rule, ks, param, value)
                    rules._keyswitch_config[rule * MAX_KEYSWITCHES_PER_RULE * MAX_CONFIG_PER_KEYSWITCH + ks * MAX_CONFIG_PER_KEYSWITCH + param] := value
                end function
            end property

            family redirects
                property evcode
                    function get(rule, ks, redirect) -> result
                        result := rules[rule].keyswitch[ks].redirects[redirect]._raw .and. 0xffff
                    end function
                    function set(rule, ks, redirect, value)
                        rules[rule].keyswitch[ks].redirects[redirect]._raw := (rules[rule].keyswitch[ks].redirects[redirect]._raw .and. 0xffff0000) + value
                    end function
                end property

                property velocity
                    function get(rule, ks, redirect) -> result
                        result := sh_right(rules[rule].keyswitch[ks].redirects[redirect]._raw, 16) .and. 0xff
                    end function
                    function set(rule, ks, redirect, value)
                        rules[rule].keyswitch[ks].redirects[redirect]._raw := (rules[rule].keyswitch[ks].redirects[redirect]._raw .and. 0xff00ffff) + sh_left(value, 16)
                    end function
                end property

                property _raw
                    function get(rule, ks, redirect) -> result
                        result := rules._keyswitch_redirects[rule * MAX_KEYSWITCHES_PER_RULE * MAX_REDIRECTS_PER_KEYSWITCH + ks * MAX_REDIRECTS_PER_KEYSWITCH + redirect]
                    end function
                    function set(rule, ks, redirect, value)
                        rules._keyswitch_redirects[rule * MAX_KEYSWITCHES_PER_RULE * MAX_REDIRECTS_PER_KEYSWITCH + ks * MAX_REDIRECTS_PER_KEYSWITCH + redirect] := value
                    end function

                end property
            end family
        end family

    end family

    // For a given CC, for each channel what is the current value.
    //   - CC chasing: from ch 1 to 2, replay last values from 1 to 2.
    //   - Sustain/breath hanging: from 1 to 2, when sustain up on 2, play against 1.
    //       - per rule, broadcast these CCs on previously active targets

    // Global configuration
    declare global_config[MAX_GLOBAL_CONFIG] := (-1)

    // Internal state

    // The keyswitch maps allow efficient lookup for a keyswitch to determine if it is active
    // for a given source MIDI channel, and which rules the keyswitch applies to.  They are
    // regenerated whenever rules are changed (or on initialization).
    //
    // The first 128 elements map to the 128 notes.  The next 128 elements are for Program Change
    // messages.  The next 126*128 elements are reserved for future use.
    //
    // Starting at 128*128, indexes are calculated as cc * value.  So for example the Spitfire
    // UACC code for spiccato is CC32 value 41, which would map to index 128*128 + 32*128 + 41 = 20521.
    // The value at this index is a bitmap of source MIDI channels that the keyswitch should
    // be listening on.
    //
    // In FlexRouter, values encoded this way are called "MIDI Event Codes" or "evcodes"


    declare ks_to_keyswitch_channels[128*128 + 128*128] := (0)

    // Indexes as above, except values are a bitmap of which rules that are applicable for the keyswitch.
    declare ks_to_rules[128*128 + 128*128] := (0)

    // A bitmap that tracks which channels MIDI events should be routed to.  Since KSP doesn't support
    // 64-bit integers, this is actually a set of two 32-bit integers for each source channel, since we
    // allow addressing all 64 MIDI channels as targets.  The first bitmap corresponds to channels 0-31
    // (LSB is channel 0) and the second corresponds to channels 32-63 (LSB is channel 32).
    declare active_routes_bitmap[NUM_SOURCE_CHANNELS * 2] := (0)

    // Tracks all target channels for all currently held notes.  This allows us to send note-off events
    // for active notes to the channels that received the note-on events, rather than the current
    // routing.  Prevents hanging notes while keyswitches are triggered during a note.  As with
    // active_routes_bitmap, we use two 32-bit bitmaps for the 64 channels.
    declare active_notes_routes_bitmap[NUM_SOURCE_CHANNELS * 128*2] := (0)

    // List of keyswitch notes that are being held.  End of list is -1.  Each entry
    // indicates the note (low 8 bits) and target channel (next 8 bits).
    declare active_keyswitch_notes_list[MAX_RULES * MAX_KEYSWITCHES_PER_RULE * MAX_REDIRECTS_PER_KEYSWITCH] := (-1)

    // Tracks all target channels for all non-zero CCs.  This doesn't tell us the value, but tells us
    // if that target channel has see a non-zero value for this CC.  This is used to prevent hanging
    // for sustain and breath CCs.  Again, two 32-bit bitmaps for the 64 channels.
    declare active_ccs_routes_bitmap[NUM_SOURCE_CHANNELS * 128 * 2] := (0)

    // Track last CC values (both globally and per source channel) for CC chasing.
    declare last_cc_values_by_source[NUM_SOURCE_CHANNELS * 128] := (-1)
    // If non-zero, value is CC value in the low 8 bits, and source channel where the CC
    // was observed in the next 8 bits.
    declare last_cc_values[128] := (-1)

    // Which source channels are null routed.
    declare blackholed_sources[NUM_SOURCE_CHANNELS] := (0)

    // A bitmap representing all source MIDI channels for keyswitches currently being pressed (because
    // multiple keyswitches can be held and activated at the same time).  Used to keep track of which
    // channels have already been reset via clear_active_routes_for_channel()
    declare active_keyswitch_source_channels_bitmap := 0


    // Non-state variable

    // FIXME: num_ks_down should be tracked per channel
    declare num_ks_down := 0
    declare is_note_on_event
    declare is_note_off_event
    declare config
    declare offset
    declare idx
    declare i
    declare j
    declare k
    declare count
    declare ks
    declare source
    declare target
    declare rule
    declare flag
    declare triggered
    declare action
    declare value
    declare evcode
    declare velocity
    // Flag to rebuild maps on next MIDI event.  Normally this was done during init
    // but Kontakt complains about too many iterations.
    declare need_maps_rebuild := 1
    declare @name

    utils_initialize()


    make_persistent(global_config)

    declare_strings_16(_rules_name)
    make_persistent(rules._config)
    make_persistent(rules._keyswitches)
    make_persistent(rules._keyswitch_config)
    make_persistent(rules._keyswitch_redirects)

    // Make the active routes persistent so keyswitches don't need to be retriggered on reload.
    make_persistent(active_routes_bitmap)
    make_persistent(blackholed_sources)


    // Before reading persisted rules, initialize global config and create an initial dummy rule.
    global_config[GLOBAL_CONFIG_VERSION] := CONFIG_VERSION
    global_config[GLOBAL_CONFIG_CC_HANGING] := 2
    initialize_rule(0, "Your first rule - rename me!")

    read_persistent_var(global_config)
    read_persistent_var(active_routes_bitmap)
    read_persistent_var(blackholed_sources)

    read_strings_16_to_array(_rules_name, rules._name)
    read_persistent_var(rules._config)
    read_persistent_var(rules._keyswitches)
    read_persistent_var(rules._keyswitch_config)
    read_persistent_var(rules._keyswitch_redirects)

    migrate_config()

    gui_initialize()
    message("")
end on

function migrate_config
    if global_config[GLOBAL_CONFIG_VERSION] < 2
        // Keyswitch redirect config was moved to separate keyswitch_redirects array
        for rule := 0 to MAX_RULES - 1
            for ks := 0 to MAX_KEYSWITCHES_PER_RULE - 1
                // Convert old undefined ks value (-1) to new one (KEYSWITCH_UNDEFINED)
                if rules[rule].keyswitch[ks].evcode < 0
                    rules[rule].keyswitch[ks].evcode := KEYSWITCH_UNDEFINED
                end if
                evcode := rules[rule].keyswitch[ks].config[0]
                velocity := rules[rule].keyswitch[ks].config[1]
                rules[rule].keyswitch[ks].config[RULE_KEYSWITCH_FLAGS] := 0
                rules[rule].keyswitch[ks].velocity._raw := VELOCITY_RANGE_DEFAULT
                // Initialize redirects
                for i := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
                    rules[rule].keyswitch[ks].redirects[i]._raw := KEYSWITCH_UNDEFINED
                end for
                // Translate action value using new consts
                if evcode  = -1
                    rules[rule].keyswitch[ks].config[RULE_KEYSWITCH_ACTION] := KEYSWITCH_ACTION_BLOCK
                else if evcode  = -2
                    rules[rule].keyswitch[ks].config[RULE_KEYSWITCH_ACTION] := KEYSWITCH_ACTION_PASSTHROUGH
                else
                    rules[rule].keyswitch[ks].config[RULE_KEYSWITCH_ACTION] := KEYSWITCH_ACTION_REDIRECT
                    rules[rule].keyswitch[ks].redirects[0].evcode := evcode
                    rules[rule].keyswitch[ks].redirects[0].velocity := velocity
                end if
            end for
        end for
    end if
    if global_config[GLOBAL_CONFIG_VERSION] < 3
        // Convert all CC keyswitches to support value ranges
        for rule := 0 to MAX_RULES - 1
            for ks := 0 to MAX_KEYSWITCHES_PER_RULE - 1
                // Convert old undefined ks value (-1) to new one (KEYSWITCH_UNDEFINED)
                if rules[rule].keyswitch[ks].evcode > 128*128
                    value := rules[rule].keyswitch[ks].evcode mod 128
                    rules[rule].keyswitch[ks].velocity.min := value
                    rules[rule].keyswitch[ks].velocity.max := value
                end if
            end for
        end for
    end if
    global_config[GLOBAL_CONFIG_VERSION] := CONFIG_VERSION
end function

function initialize_rule(idx, name)
    rules[idx].name := name
    rules[idx].config[RULE_DEFINED] := 1
    rules[idx].config[RULE_ENABLED] := 1
    rules[idx].config[RULE_KEYSWITCH_CHANNEL] := 1
    rules[idx].config[RULE_SOURCE_CHANNEL] := -1
    rules[idx].config[RULE_TARGET_CHANNEL] := 1
    rules[idx].config[RULE_CC_CHASING] := 2
    for i := 0 to MAX_KEYSWITCHES_PER_RULE - 1
        rules[idx].keyswitch[i].evcode := KEYSWITCH_UNDEFINED
        rules[idx].keyswitch[i].velocity._raw := VELOCITY_RANGE_DEFAULT
        rules[idx].keyswitch[i].config[RULE_KEYSWITCH_ACTION] := KEYSWITCH_ACTION_BLOCK
        rules[idx].keyswitch[i].config[RULE_KEYSWITCH_FLAGS] := 0
        rules[idx].keyswitch[i].config[RULE_KEYSWITCH_SOURCE_CHANNEL] := 0
        rules[idx].keyswitch[i].config[RULE_KEYSWITCH_TARGET_CHANNEL] := 0
        for j := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
            rules[idx].keyswitch[i].redirects[j].evcode := KEYSWITCH_UNDEFINED
         end for

    end for
end function

function copy_rule(src, dst)
    rules[dst].name := rules[src].name
    rules[dst].config[RULE_DEFINED] := rules[src].config[RULE_DEFINED]
    rules[dst].config[RULE_ENABLED] := rules[src].config[RULE_ENABLED]
    rules[dst].config[RULE_KEYSWITCH_CHANNEL] := rules[src].config[RULE_KEYSWITCH_CHANNEL]
    rules[dst].config[RULE_SOURCE_CHANNEL] := rules[src].config[RULE_SOURCE_CHANNEL]
    rules[dst].config[RULE_TARGET_CHANNEL] := rules[src].config[RULE_TARGET_CHANNEL]
    rules[dst].config[RULE_CC_CHASING] := rules[src].config[RULE_CC_CHASING]
    for i := 0 to MAX_KEYSWITCHES_PER_RULE - 1
        rules[dst].keyswitch[i].evcode := rules[src].keyswitch[i].evcode
        rules[dst].keyswitch[i].velocity._raw := rules[src].keyswitch[i].velocity._raw
        rules[dst].keyswitch[i].config[RULE_KEYSWITCH_FLAGS] := rules[src].keyswitch[i].config[RULE_KEYSWITCH_FLAGS]
        rules[dst].keyswitch[i].config[RULE_KEYSWITCH_ACTION] := rules[src].keyswitch[i].config[RULE_KEYSWITCH_ACTION]
        rules[dst].keyswitch[i].config[RULE_KEYSWITCH_SOURCE_CHANNEL] := rules[src].keyswitch[i].config[RULE_KEYSWITCH_SOURCE_CHANNEL]
        rules[dst].keyswitch[i].config[RULE_KEYSWITCH_TARGET_CHANNEL] := rules[src].keyswitch[i].config[RULE_KEYSWITCH_TARGET_CHANNEL]

        // Copy keyswitch redirects
        for j := 0 to MAX_REDIRECTS_PER_KEYSWITCH - 1
            evcode := rules[src].keyswitch[i].redirects[j].evcode
            velocity := rules[src].keyswitch[i].redirects[j].velocity
            rules[dst].keyswitch[i].redirects[j].evcode := evcode
            rules[dst].keyswitch[i].redirects[j].velocity := velocity
        end for
    end for
end function

function get_next_rule_idx() -> idx
    idx := -1
    for i := 0 to MAX_RULES - 1
        if idx = -1 and rules[i].config[RULE_DEFINED] = 0
            idx := i
        end if
    end for
end function

// Given the current rule configuration, builds the ks_to_keyswitch_channels and ks_to_rules
// maps.  These maps allow is to efficiently determine if an event is a keyswitch (which must be
// decided for each and every MIDI event so must be efficient), and to quickly converge on the rule
// configuration if an event is determined to be a keyswitch.

// This function must be invoked whenever rule configuration is modified.  Since it is called
// from several places, this isn't an inlined function.
function build_ks_maps
    for i := 0 to num_elements(ks_to_keyswitch_channels) - 1
        ks_to_keyswitch_channels[i] := 0
        ks_to_rules[i] := 0
    end for
    for i := 0 to MAX_RULES - 1
        if rules[i].config[RULE_DEFINED] = 1 and rules[i].config[RULE_ENABLED] = 1
            for j := 0 to MAX_KEYSWITCHES_PER_RULE - 1
                evcode := rules[i].keyswitch[j].evcode
                if evcode # KEYSWITCH_UNDEFINED
                    if evcode < 128*128 or evcode mod 128 # 0
                        // Not a CC with range, so map the given evcode.
                        map_ks_evcode(i, evcode)
                    else
                        // Evcode may be a range-based CC, so need to map all CC values
                        // within range.
                        for value := rules[i].keyswitch[j].velocity.min to rules[i].keyswitch[j].velocity.max
                            map_ks_evcode(i, evcode + value)
                        end for
                    end if
                end if
            end for
        end if
    end for
end function

function map_ks_evcode(rule, evcode)
    source := rules[rule].config[RULE_KEYSWITCH_CHANNEL]
    if source = -1
        // Keyswitches are omni
        for source := 0 to NUM_SOURCE_CHANNELS - 1
            ks_to_keyswitch_channels[evcode] := ks_to_keyswitch_channels[evcode] .or. sh_left(1, source)
        end for
    else
        // Keyswitches only on one channel.
        ks_to_keyswitch_channels[evcode] := ks_to_keyswitch_channels[evcode] .or. sh_left(1, source - 1)
    end if
    ks_to_rules[evcode] := ks_to_rules[evcode] .or. sh_left(1, rule)
end function

// Configures routing so that all non-keyswitch events on the given source channel
// (offset from 0, i.e. MIDI channel 1 is value 0) are diverted to the given target
// channel (also offset from 0).

// If the source channel is not found in active_keyswitch_source_channels_bitmap
// then all existing routes for the source are cleared and the channel is added
// to the bitmap.

// This allows for multiple targets to be configured for a given source.  This
// function must be called for each source.
function set_active_route_for_channel(rule, source, target)
    declare idx
    if active_keyswitch_source_channels_bitmap .and. sh_left(1, source) = 0
        // The routing for this source channel hasn't yet been cleared for this keyswitch event,
        // so clear it now before establishing a new route.
        clear_active_routes_for_channel(source)
        active_keyswitch_source_channels_bitmap := active_keyswitch_source_channels_bitmap .or. sh_left(1, source)
    end if

    idx := source * 2
    if target < 32
        active_routes_bitmap[idx] := active_routes_bitmap[idx] .or. sh_left(1, target)
    else
        active_routes_bitmap[idx + 1] := active_routes_bitmap[idx + 1] .or. sh_left(1, target - 32)
    end if
end function


// Determine if the user config requires the given CC should have zero-values routed
// to prior keyswitch targets, to prevent for example sustain pedal hanging.
function should_prevent_cc_hang(cc) -> result
    config := global_config[GLOBAL_CONFIG_CC_HANGING]
    if config = 1
        result := 1
    else if config = 2 and (cc = 2 or cc = 64)
        result := 1
    else
        result := 0
    end if
end function

function should_chase_cc(rule, cc) -> result
    config := rules[rule].config[RULE_CC_CHASING]
    if config = 1
        result := 1
    else if config = 2 and (cc = 1 or cc = 2 or cc = 11 or (cc >= 64 and cc <= 69))
        result := 1
    else
        result := 0
    end if
end function

function chase_ccs_for_omni(rule, target)
    declare i
    declare channel
    for i := 1 to 127
        if last_cc_values[i] # -1
            value := last_cc_values[i] .and. 0xff
            channel := sh_right(last_cc_values[i], 8) .and. 0xff
            _chase(rule, channel, target, i, value)
            if value = 0
                // Having chased a zero value for this CC, unset it so it won't be chased
                // in future (unless a non-zero value is seen)
                last_cc_values[i] := -1
            end if
        end if
    end for
end function

function chase_ccs_for_source_channel(rule, source, target)
    declare i
    for i := 1 to 127
        value := last_cc_values_by_source[source * NUM_SOURCE_CHANNELS + i]
        _chase(rule, source, target, i, value)
        if value = 0
            // Having chased a zero value for this CC, unset it so it won't be chased
            // in future (unless a non-zero value is seen)
            last_cc_values_by_source[source * NUM_SOURCE_CHANNELS + i] := -1
        end if
    end for
end function

function _chase(rule, source, target, cc, value)
    declare idx
    declare offset
    // It was intuitive to avoid chasing if source == target, but intuition failed: that's still
    // necessary because the source could have been rerouted to a different target, so we
    // still need to chase CCs if we switch back.
    if value >= 0
        flag := should_chase_cc(rule, cc)
        if flag = 1
            set_midi(target, MIDI_COMMAND_CC, cc, value)
            if value > 0
                // If we just chased a non-zero value, then keep track of the target channel
                // in the active CCs routes.  For example, if we're chasing sustain pedal
                // across multiple channels, we want to ensure we are able to later replay
                // sustain pedal off to this target channel for anti hanging.
                idx := source * 128 * 2 + cc * 2
                if target < 32
                    active_ccs_routes_bitmap[idx] := active_ccs_routes_bitmap[idx] .or. sh_left(1, target)
                else
                    active_ccs_routes_bitmap[idx + 1] := active_ccs_routes_bitmap[idx + 1] .or. sh_left(1, target)
                end if
            end if
        end if
    end if
end function


function blackhole_source(channel)
    clear_active_routes_for_channel(channel)
    blackholed_sources[channel] := 1
end function

// Clears all active routes for the given channel.  The routes would have been previously
// established by calling set_active_route_for_channel()
function clear_active_routes_for_channel(channel)
    active_routes_bitmap[channel * 2 + 0] := 0
    active_routes_bitmap[channel * 2 + 1] := 0
    blackholed_sources[channel] := 0
end function


// Returns a count of the number of keyswitches for the given rule idx
function get_num_keyswitches_for_rule(rule) -> count
    count := 0
    while rules[rule].keyswitch[count].evcode # KEYSWITCH_UNDEFINED
        inc(count)
    end while
end function


// Returns the index (offset from 0) for the first instance of the given
// keyswitch if found, otherwise returns -1 if not found.
function get_keyswitch_idx_for_rule(rule, ks, velocity) -> idx
    idx := -1
    j := 0
    while j < MAX_KEYSWITCHES_PER_RULE and idx = -1
        if rules[rule].keyswitch[j].evcode = ks or ...
           (ks >= 128*128 and rules[rule].keyswitch[j].evcode = ks / 128 * 128)
            // For note-based keyswitches, only trigger if the velocity is in range.
            // Similarly, for CCs, ensure the CC value is within range.
            if (ks > 128 and ks < 128*128) or ...
               (velocity >= rules[rule].keyswitch[j].velocity.min and ...
                velocity <= rules[rule].keyswitch[j].velocity.max) or ...
               velocity = -1
                idx := j
            end if
        end if
        inc(j)
    end while
end function


// Routes a MIDI event to one or more channels (up to 64 of them).  The target channels are
// determined from the given bitmap at the given index for channels 0-31, and the subsequent index
// for channels 32-63.
function route_midi_event(bitmap, idx, command, byte1, byte2)
    if bitmap[idx] # 0
        _route_midi_event_int32(bitmap[idx], 0, command, byte1, byte2)
    end if
    if bitmap[idx + 1] # 0
        _route_midi_event_int32(bitmap[idx + 1], 32, command, byte1, byte2)
    end if
end function


function _route_midi_event_int32(bitmap, channel_offset, command, byte1, byte2)
    // TODO: future optimization: could unroll this a bit, testing each byte in the integer and only
    // if nonzero would we iterate through each bit in that byte.
    for i := 0 to 31
        if bitmap .and. sh_left(1, i) # 0
            set_midi(channel_offset + i, command, byte1, byte2)
        end if
    end for
end function


function trigger_keyswitch_for_rule(rule, ks, idx)
    // Set the active route from source channel(s) to target channel.
    source := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_SOURCE_CHANNEL]
    if source = 0
        // Use rule default source
        source := rules[rule].config[RULE_SOURCE_CHANNEL]
    end if

    target := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_TARGET_CHANNEL]
    if target = 0
        // Use rule default target
        target := rules[rule].config[RULE_TARGET_CHANNEL]
    end if

    flag := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_FLAGS]
    if target > 0
        target := target - 1
        action := rules[rule].keyswitch[idx].config[RULE_KEYSWITCH_ACTION]
        if flag .and. KEYSWITCH_FLAG_IGNORE_ROUTING = 0
            if source = -1
                // Source is omni: route all channels to keyswitch target.
                for j := 0 to NUM_SOURCE_CHANNELS - 1
                    set_active_route_for_channel(rule, j, target)
                end for
                chase_ccs_for_omni(rule, target)
            else
                // Route specific channel to keyswitch target.
                set_active_route_for_channel(rule, source - 1, target)
                chase_ccs_for_source_channel(rule, source - 1, target)
            end if
        end if

        debug("keyswitch " & ks & " triggered (action " & action & "), route " & source & " -> " & target + 1 & " (" & rules[rule].name & ")")

        // Before triggering the new keyswitch, release any held keyswitch notes
        declare noteidx := 0
        while active_keyswitch_notes_list[noteidx] # -1
            value := active_keyswitch_notes_list[noteidx]
            active_keyswitch_notes_list[noteidx] := -1
            set_midi(sh_right(value, 8) .and. 0xff, MIDI_COMMAND_NOTE_ON, value .and. 0xff, 0)
            noteidx := noteidx + 1
        end while

        if action # KEYSWITCH_ACTION_BLOCK
            // Keyswitch action is not set to blocked, so we route it.
            if action = KEYSWITCH_ACTION_PASSTHROUGH
                // Rule is configured for passthrough.  Send the event to the rule target.
                set_midi(target, MIDI_COMMAND, MIDI_BYTE_1, MIDI_BYTE_2)
            else
                // Action is redirect.
                i := 0
                while rules[rule].keyswitch[idx].redirects[i].evcode # KEYSWITCH_UNDEFINED and i < MAX_REDIRECTS_PER_KEYSWITCH
                    evcode := rules[rule].keyswitch[idx].redirects[i].evcode
                    if evcode < 128
                        // Redirect to a note
                        velocity := rules[rule].keyswitch[idx].redirects[i].velocity
                        set_midi(target, MIDI_COMMAND_NOTE_ON, evcode, velocity)

                        if flag .and. KEYSWITCH_FLAG_HOLD_NOTES # 0
                            // Track keyswitch note which is being held until next keyswitch.  This is O(n) with
                            // respect to the number of held keyswitches so it will degrade in pathological cases
                            // but in practice the list will be quite small.
                            noteidx := 0
                            while active_keyswitch_notes_list[noteidx] # -1
                                noteidx := noteidx + 1
                            end while
                            active_keyswitch_notes_list[noteidx] := evcode + sh_left(target, 8)
                        else
                            set_midi(target, MIDI_COMMAND_NOTE_ON, evcode, 0)
                        end if
                    else if evcode < 256
                        // Redirect to program change
                        set_midi(target, MIDI_COMMAND_PROGRAM_CHANGE, evcode - 128, 0)
                    else
                        // Redirect CC value
                        set_midi(target, MIDI_COMMAND_CC, evcode / 128 - 128, evcode mod 128)
                    end if
                    i := i + 1
                end while
            end if
        end if
    // Do not process blackhole if keyswitch is set for no routing
    else if flag .and. KEYSWITCH_FLAG_IGNORE_ROUTING = 0
        // Source is to be blackholed.
        if source = -1
            // Source is omni, so blackhole all channels.
            for j := 0 to NUM_SOURCE_CHANNELS - 1
                blackhole_source(j)
            end for
        else
            blackhole_source(source - 1)
        end if
    end if // target > 0
end function


on midi_in
    if need_maps_rebuild = 1
        need_maps_rebuild := 0
        call build_ks_maps
    end if
    if MIDI_COMMAND = MIDI_COMMAND_NOTE_ON and MIDI_BYTE_2 > 0
        is_note_on_event := 1
    else
        is_note_on_event := 0
    end if

    if MIDI_COMMAND = MIDI_COMMAND_NOTE_ON and MIDI_BYTE_2 = 0 or MIDI_COMMAND = MIDI_COMMAND_NOTE_OFF
        is_note_off_event := 1
    else
        is_note_off_event := 0
    end if

    // Determine key/CC switch value from event
    if is_note_on_event = 1 or is_note_off_event = 1
        ks := MIDI_BYTE_1
    else if MIDI_COMMAND = MIDI_COMMAND_CC and MIDI_BYTE_1 >= 1
        ks := 128*128 + MIDI_BYTE_1 * 128 + MIDI_BYTE_2
    else if MIDI_COMMAND = MIDI_COMMAND_PROGRAM_CHANGE
        ks := 128 + MIDI_BYTE_1
    else
        // This MIDI event is unsupported as a keyswitch.
        ks := KEYSWITCH_UNDEFINED
    end if

    if ks # KEYSWITCH_UNDEFINED and (button_keyswitch_midi_learn = 1 or button_keyswitch_midi_learn_inc = 1)
        // Keyswitch learn for rule (MIDI Learn button)
        ignore_midi
        if is_note_on_event = 1 or MIDI_COMMAND = MIDI_COMMAND_CC or MIDI_COMMAND = MIDI_COMMAND_PROGRAM_CHANGE
            call gui_append_keyswitch_to_selected_rule
        end if
    else if ks # KEYSWITCH_UNDEFINED and button_keyswitch_midi_find = 1
        // Keyswitch select (MIDI Find button) for rule
        ignore_midi
        if is_note_on_event = 1 or MIDI_COMMAND = MIDI_COMMAND_CC or MIDI_COMMAND = MIDI_COMMAND_PROGRAM_CHANGE
            gui_set_selected_keyswitch_by_ks(ks, MIDI_BYTE_2)
        end if
    else if ks # KEYSWITCH_UNDEFINED and keyswitch_redirect_midi_learn_index # -1 // FIXME
        // MIDI learn for keyswitch redirect rule (Redirect MIDI Learn button)
        ignore_midi
        if is_note_on_event = 1 or MIDI_COMMAND = MIDI_COMMAND_CC or MIDI_COMMAND = MIDI_COMMAND_PROGRAM_CHANGE
            gui_set_selected_keyswitch_redirect(ks, MIDI_BYTE_2)
        end if

    else if ks # KEYSWITCH_UNDEFINED and ks_to_keyswitch_channels[ks] .and. sh_left(1, MIDI_CHANNEL) # 0
        // Event is a configured key/CC switch for the source MIDI channel.
        if is_note_on_event = 1 or MIDI_COMMAND = MIDI_COMMAND_CC or MIDI_COMMAND = MIDI_COMMAND_PROGRAM_CHANGE
            if num_ks_down = 0
                active_keyswitch_source_channels_bitmap := 0
            end if

            // Block the keyswitch event from propagating.  If applicable, we will route the
            // event to the appropriate targets based on rule configuration, or regenerate it
            // in the case that this is a note-based keyswitch that didn't match the configured
            // velocity range.
            triggered := 0
            ignore_midi

            // Iterate through all applicable rules and apply target channel to active routes.
            // This isn't as cheap as it might be, although it's not terrible and it's only done
            // on a keyswitch event.
            for rule := 0 to MAX_GUI_RULES - 1
                if ks_to_rules[ks] .and. sh_left(1, rule) # 0 and (rules[rule].config[RULE_KEYSWITCH_CHANNEL] = MIDI_CHANNEL + 1 ...
                    or rules[rule].config[RULE_KEYSWITCH_CHANNEL] = -1)
                    // This keyswitch event applies to the rule at index rule.  Now set up the
                    // routing for each matching keyswitch in the rule.
                    //
                    // TODO: use a sentinel to indicate the end of keyswitches to avoid
                    // needlessly iterating all of them.
                    for idx := 0 to MAX_KEYSWITCHES_PER_RULE - 1
                        // We know the ks evcode matches this rule if the rule evcode is equal, or
                        // for CC keyswitches, if the CC number matches.  We'll test the note
                        // velocity and CC value next.
                        if rules[rule].keyswitch[idx].evcode = ks or ...
                           (ks >= 128*128 and rules[rule].keyswitch[idx].evcode = ks / 128 * 128)
                            // For note-based keyswitches, only trigger if the velocity is in range.
                            // Similarly, for CCs, ensure the CC value is within range.
                            if (ks > 128 and ks < 128*128) or ...
                               (MIDI_BYTE_2 >= rules[rule].keyswitch[idx].velocity.min and ...
                                MIDI_BYTE_2 <= rules[rule].keyswitch[idx].velocity.max)
                                trigger_keyswitch_for_rule(rule, ks, idx)
                                triggered := 1
                            end if
                        end if
                    end for
                end if
            end for

            if triggered = 0
                // Regenerate the original MIDI event because the velocity was out of range.
                set_midi(target, MIDI_COMMAND, MIDI_BYTE_1, MIDI_BYTE_2)
            end if
            // Track number of currently held keyswitches (for layering)
            if is_note_on_event = 1
                inc(num_ks_down)
            end if
        else if is_note_off_event = 1
            // FIXME: if ks action is block, prevent note-off from propagating.
            if num_ks_down > 0
                dec(num_ks_down)
            end if
        end if
    else
        // Non-keyswitch event.  Route to active targets.
        // FIXME: find better names
        offset := MIDI_CHANNEL * 2
        idx := MIDI_CHANNEL * 128 * 2 + MIDI_BYTE_1 * 2

        // Prevent note hanging.
        if is_note_off_event = 1
            // Check to see if the active channels for the given note is different from the active routes
            // for this MIDI channel.  If it is, then send the note off event to those channels.  It's
            // technically redundant to route the event to the active channels later, but it's not worth
            // avoiding the repeated note off for this uncommon case, since the active note routes is
            // a superset of the active routes for note-off events.
            if active_notes_routes_bitmap[idx] # active_routes_bitmap[offset] or ...
               active_notes_routes_bitmap[idx + 1] # active_routes_bitmap[offset + 1]
                route_midi_event(active_notes_routes_bitmap, idx, MIDI_COMMAND, MIDI_BYTE_1, MIDI_BYTE_2)
            end if
            // Having just sent the note off event to all relevant channels, clear the bitmap.
            active_notes_routes_bitmap[idx] := 0
            active_notes_routes_bitmap[idx + 1] := 0
        else if is_note_on_event = 1
            // Track all active routing channels for the note being triggered.
            active_notes_routes_bitmap[idx] := active_notes_routes_bitmap[idx] .or. active_routes_bitmap[offset]
            active_notes_routes_bitmap[idx + 1] := active_notes_routes_bitmap[idx + 1] .or. active_routes_bitmap[offset + 1]
        end if

        // Special treatment for CC events.
        if MIDI_COMMAND = MIDI_COMMAND_CC
            // Remember this value for CC chasing.
            last_cc_values_by_source[MIDI_CHANNEL * NUM_SOURCE_CHANNELS + MIDI_BYTE_1] := MIDI_BYTE_2
            last_cc_values[MIDI_BYTE_1] := MIDI_BYTE_2 .or. sh_left(MIDI_CHANNEL, 8)

            if MIDI_BYTE_1 = 123
                // Handle All Notes Off message
                // FIXME: because num_ks_down is global rather than per channel, we clear the entire
                // active keyswitch source bitmap.  Once we fix num_ks_down to be tracked per channel,
                // this should be revised to just 0 the appropriate bit for the channel.  For now
                // we'll live with the bug because the common case is that CC123 will be blasted on
                // all channels.
                num_ks_down := 0
                active_keyswitch_source_channels_bitmap := 0
                // Determine which destination channels need to receive the CC123 by looking at the
                // destination channels bitmap for all active notes for this source channel.
                j := 0 // bitmap for channels 0-31
                k := 0 // bitmap for channels 32-63
                for i := MIDI_CHANNEL * 128 * 2 to MIDI_CHANNEL * 128 * 2 + 127 * 2 step 2
                    j := j .or. active_notes_routes_bitmap[i]
                    k := k .or. active_notes_routes_bitmap[i + 1]
                    // Now clear any channels for this note.
                    active_notes_routes_bitmap[i] := 0
                    active_notes_routes_bitmap[i + 1] := 0
                end for
                _route_midi_event_int32(j, 0, MIDI_COMMAND, MIDI_BYTE_1, MIDI_BYTE_2)
                _route_midi_event_int32(k, 32, MIDI_COMMAND, MIDI_BYTE_1, MIDI_BYTE_2)
            else if MIDI_BYTE_2 = 0
                // Prevent CC hanging: copy 0-value event to all target channels this CC was previously
                // sent to across prior keyswitches.
                j := should_prevent_cc_hang(MIDI_BYTE_1)
                if j = 1 and (active_ccs_routes_bitmap[idx] # active_routes_bitmap[offset] or ...
                   active_ccs_routes_bitmap[idx + 1] # active_routes_bitmap[offset + 1])
                    route_midi_event(active_ccs_routes_bitmap, idx, MIDI_COMMAND, MIDI_BYTE_1, MIDI_BYTE_2)
                end if
                // Having just sent the CC off event to all relevant channels, clear the bitmap.
                active_ccs_routes_bitmap[idx] := 0
                active_ccs_routes_bitmap[idx + 1] := 0
            else
                // This is a non-zero CC value: keep track of all active routing
                // channels for the CC being triggered.
                active_ccs_routes_bitmap[idx] := active_ccs_routes_bitmap[idx] .or. active_routes_bitmap[offset]
                active_ccs_routes_bitmap[idx + 1] := active_ccs_routes_bitmap[idx + 1] .or. active_routes_bitmap[offset + 1]
            end if
        end if

        // Now route the event to all active channels if there are active routes for this MIDI channel.
        // If there aren't any active routes, we don't interfere with the event.
        if active_routes_bitmap[offset] # 0 or active_routes_bitmap[offset + 1] # 0
            ignore_midi
            route_midi_event(active_routes_bitmap, offset, MIDI_COMMAND, MIDI_BYTE_1, MIDI_BYTE_2)
        else if blackholed_sources[MIDI_CHANNEL] # 0
            ignore_midi
        end if
        // message("")
        // debug("MIDI: cmd=" & MIDI_COMMAND & ", ch=" & MIDI_CHANNEL & ", b1=" & MIDI_BYTE_1 & ", b2=" & MIDI_BYTE_2 & ", ks=" & ks)
    end if
end on
